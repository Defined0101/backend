# Food Recommendation System API

[![Python Version](https://img.shields.io/badge/python-3.9+-blue.svg)](https://www.python.org/)
[![Framework](https://img.shields.io/badge/Framework-FastAPI%200.104.1-green.svg)](https://fastapi.tiangolo.com/)
[![Database](https://img.shields.io/badge/Database-PostgreSQL-blue.svg)](https://www.postgresql.org/)
[![Vector DB](https://img.shields.io/badge/Vector%20DB-Qdrant-red.svg)](https://qdrant.tech/)
[![License](https://img.shields.io/badge/License-None-lightgrey.svg)]() <!-- Add a LICENSE file -->

This repository contains the backend API for a Food Recommendation System, developed as a graduation project. The system leverages FastAPI, PostgreSQL, Qdrant, and potentially Celery to deliver personalized recipe recommendations and manage user interactions like saving, liking, and disliking recipes.

## Features

*   **User Management:** Basic user profile information.
*   **Recipe Management:** Access detailed recipe information (ingredients, instructions, nutritional info, category, labels).
*   **Ingredient Management:** Track available ingredients.
*   **User Interactions:**
    *   Save/Unsave recipes.
    *   Like/Unlike recipes.
    *   Dislike/Undislike recipes.
    *   View saved, liked, and disliked recipes.
*   **Personalization:**
    *   Manage user preferences and dietary restrictions (allergies).
    *   Get personalized recipe recommendations using **Qdrant** vector search based on user interactions.
    *   "Surprise Me" feature for random recipe suggestions (excluding disliked ones).
*   **Search & Filtering:** (Implied capabilities, potentially enhanceable) Advanced recipe search based on various criteria.

## Technology Stack

*   **Backend Framework**: [FastAPI](https://fastapi.tiangolo.com/) (`0.104.1`)
*   **Web Server**: [Uvicorn](https://www.uvicorn.org/) (`0.23.2`)
*   **Database**: [PostgreSQL](https://www.postgresql.org/) (Requires external setup or separate Docker service)
*   **Vector Database**: [Qdrant](https://qdrant.tech/) (via `qdrant-client`)
*   **ORM**: [SQLAlchemy](https://www.sqlalchemy.org/) (`2.0.23`)
*   **Data Validation**: [Pydantic](https://pydantic-docs.helpmanual.io/) (`2.4.2`)
*   **Containerization**: [Docker](https://www.docker.com/) & [Docker Compose](https://docs.docker.com/compose/)
*   **Background Tasks**: [Celery](https://docs.celeryq.dev/en/stable/) (for asynchronous embedding updates, via `celery[redis]`)
*   **Message Broker**: [Redis](https://redis.io/) (`>=4.0.0`)
*   **ML/Embeddings**: [PyTorch](https://pytorch.org/) (via `torch`, likely for generating embeddings)
*   **Other Key Libraries**: `psycopg2-binary`, `python-dotenv`, `pydantic-settings`, `python-jose`, `passlib`, `python-multipart`, `email-validator`
*   **API Documentation**: Swagger UI / OpenAPI (automatically generated by FastAPI)

## Project Structure

```
.
├── .dockerignore         # Files to ignore in Docker build context
├── .git/                 # Git directory
├── .github/              # GitHub Actions/Workflows (Optional)
├── .gitignore            # Files ignored by Git
├── .env.example          # Example environment variables file
├── Dockerfile            # Defines the Docker image for the application
├── Makefile              # Convenience commands (build, run, test, lint)
├── README.md             # This file
├── ProjectStatus.md      # Project status notes (Optional)
├── celerybeat-schedule   # Celery Beat schedule file
├── docker-compose.yml    # Docker Compose configuration (app, qdrant, redis, celery)
├── requirements.txt      # Python package dependencies
├── app/                  # Main application source code
│   ├── api/              # API endpoints (routers)
│   │   ├── endpoints/    # Specific endpoint modules (users, recipes, etc.)
│   │   └── api.py        # Main API router aggregation
│   ├── core/             # Core components (config, database connection)
│   │   ├── config.py     # Application configuration settings
│   │   └── database.py   # Database session management
│   ├── models/           # SQLAlchemy ORM models
│   │   └── models.py     # Database table definitions
│   ├── schemas/          # Pydantic schemas (data validation, serialization)
│   │   ├── *.py          # Schemas for different data models
│   ├── services/         # Business logic layer
│   │   ├── *.py          # Services for different domains (user, recipe, etc.)
│   ├── utils/            # Utility functions (e.g., embedding tracker)
│   │   └── embedding_tracker.py
│   ├── celery_app.py     # Celery application instance (or similar name)
│   └── main.py           # FastAPI application entry point
├── qdrant/               # Qdrant persistent storage volume mapping
└── venv/                 # Python virtual environment (if not using Docker exclusively)
```
*(Note: Some directories like `.github` or files like `.env.example` might not exist yet but are good practices)*

## Setup and Installation

### Prerequisites

*   [Docker](https://docs.docker.com/get-docker/) and [Docker Compose](https://docs.docker.com/compose/install/)
*   Git
*   A running PostgreSQL database accessible from the Docker network or localhost (if running manually).

### Using Docker (Recommended)

1.  **Clone the Repository:**
    ```bash
    git clone <repository-url>
    cd backend
    ```

2.  **Configure Environment Variables:**
    Create a `.env` file in the root directory. Add the following variables, adjusting values as necessary:
    ```env
    # PostgreSQL Database
    # Ensure this URL points to your running PostgreSQL instance.
    # If running PostgreSQL as another Docker service (e.g., named 'postgres-db'),
    # you might use: postgresql://user:password@postgres-db:5432/dbname
    # If running on host machine from Docker, might need host.docker.internal or similar.
    DATABASE_URL=postgresql://user:password@host:port/dbname

    # Qdrant (Uses service name from docker-compose.yml)
    QDRANT_HOST=qdrant
    QDRANT_PORT=6333
    # QDRANT_API_KEY= # Optional: Add if Qdrant requires an API key

    # Celery (Uses service name from docker-compose.yml)
    CELERY_BROKER_URL=redis://redis:6379/0
    CELERY_RESULT_BACKEND=redis://redis:6379/0

    # FastAPI/Uvicorn
    DEBUG=True # Set to False for production deployments
    SECRET_KEY= # Generate a strong secret key

    # Add other necessary application-specific variables...
    ```

3.  **Build and Run with Docker Compose:**
    Use the provided `Makefile` for convenience:
    *   **Build images:**
        ```bash
        make build
        ```
    *   **Start all services in detached mode:**
        ```bash
        make up
        ```
    *   **View logs:**
        ```bash
        make logs
        # Or for a specific service: docker compose logs -f backend
        ```
    *   **Stop services:**
        ```bash
        make down
        ```
    *   **Access backend shell:**
        ```bash
        make shell
        ```
    *   **Clean up (stops containers, removes volumes, prunes system):**
        ```bash
        make clean
        ```

    The API will be available at `http://localhost:8000` (as per `docker-compose.yml`).

### Manual Installation (Alternative, for local development without Docker)

1.  **Clone the Repository:** (As above)
2.  **Ensure Prerequisites:** Make sure PostgreSQL, Redis, and Qdrant are installed and running locally or accessible.
3.  **Create and Activate Virtual Environment:**
    ```bash
    python -m venv venv
    source venv/bin/activate # Linux/macOS
    # venv\Scripts\activate # Windows
    ```
4.  **Install Dependencies:**
    ```bash
    pip install -r requirements.txt
    ```
5.  **Set Environment Variables:**
    Set the variables listed in step 2 (Using Docker) directly in your shell, adjusting hosts/ports for your local setup (e.g., `localhost` instead of service names like `qdrant` or `redis`).
6.  **Start the Application Components:**
    *   **FastAPI App:** `make dev` or `uvicorn app.main:app --reload --host 0.0.0.0 --port 8000`
    *   **Celery Worker:** `celery -A app.celery_app worker --loglevel=info` (in a separate terminal)
    *   **Celery Beat:** `celery -A app.celery_app beat --loglevel=info` (in a separate terminal)

## Running the Application

*   **Docker:** Use `docker compose up` as described above. Access the API at the port specified in your `docker-compose.yml` (e.g., `http://localhost:8000`).
*   **Manual:** Use `uvicorn app.main:app --reload` as described above. Access the API at `http://localhost:8000`.

## API Documentation (Swagger UI)

Once the application is running, interactive API documentation is available at:

*   `/docs` (e.g., `http://localhost:8000/docs`)

This interface allows you to explore and test all available API endpoints.

## Key API Endpoints (Illustrative)

*(Note: Actual paths might differ; check `/docs` for the source of truth)*

**Recipes:**

*   `GET /api/v1/recipes/{recipe_id}`: Get detailed recipe information.
*   `GET /api/v1/recipes/card/{recipe_id}?fields=...`: Get specific fields for a recipe card.
*   `GET /api/v1/recipes/recommendations`: Get personalized recommendations for the current user.
*   `GET /api/v1/recipes/surprise`: Get a random "surprise me" recipe ID.
*   `POST /api/v1/recipes/{recipe_id}/like`: Like a recipe.
*   `DELETE /api/v1/recipes/{recipe_id}/like`: Unlike a recipe.
*   `POST /api/v1/recipes/{recipe_id}/dislike`: Dislike a recipe.
*   `DELETE /api/v1/recipes/{recipe_id}/dislike`: Remove dislike from a recipe.
*   `POST /api/v1/recipes/{recipe_id}/save`: Save a recipe.
*   `DELETE /api/v1/recipes/{recipe_id}/save`: Unsave a recipe.

**User Profile & Preferences:**

*   `GET /api/v1/users/me/saved-recipes`: Get recipes saved by the current user.
*   `GET /api/v1/users/me/liked-recipes`: Get recipes liked by the current user.
*   `GET /api/v1/users/me/disliked-recipes`: Get recipes disliked by the current user.
*   `GET /api/v1/users/me/preferences`: Get current user's preferences.
*   `POST /api/v1/users/me/preferences`: Set current user's preferences.
*   `GET /api/v1/users/me/allergies`: Get current user's allergies.
*   `POST /api/v1/users/me/allergies`: Set current user's allergies.
*   `GET /api/v1/users/me/ingredients`: Get ingredients in the user's inventory.
*   `POST /api/v1/users/me/ingredients`: Set ingredients in the user's inventory.

**General Data:**

*   `GET /api/v1/ingredients`: Get a list of all available ingredients.
*   `GET /api/v1/preferences`: Get a list of all available dietary preferences.
*   `GET /api/v1/categories`: Get a list of all available recipe categories.

**System:**

*   `GET /health`: Health check endpoint.

## Qdrant Integration

*   Qdrant is used as a vector database to store recipe embeddings (numerical representations).
*   User interactions (likes, dislikes) trigger updates to user preference vectors via Celery tasks.
*   The `/api/v1/recipes/recommendations` endpoint queries Qdrant to find recipes with embeddings similar to the user's preference vector, providing personalized results.

## Celery Background Tasks

*   Celery is used with Redis as the message broker for handling asynchronous tasks.
*   Its primary role is to track changes in user liked and disliked recipes.
*   When a user likes or dislikes a recipe, a Celery task is triggered to update the corresponding user's embedding vector in Qdrant.
*   This ensures that the recommendation engine uses the latest user preferences without blocking the main API request flow.
*   Celery requires a message broker (Redis) and potentially a result backend, configured in `docker-compose.yml` and `.env`.

## Contributing

Contributions are welcome! Please follow these steps:

1.  Fork the repository.
2.  Create a new branch (`git checkout -b feature/your-feature-name`).
3.  Make your changes.
4.  Ensure tests pass (if applicable).
5.  Commit your changes (`git commit -m 'Add some feature'`).
6.  Push to the branch (`git push origin feature/your-feature-name`).
7.  Open a Pull Request.

Please adhere to the coding style and conventions used in the project. Consider adding tests for new features.

## License

This project currently does not have a license file. Consider adding one (e.g., MIT, Apache 2.0) based on your requirements.

---

*Feel free to update this README further as the project evolves.*